import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';
import { execFile } from 'child_process';
import { promisify } from 'util';
import * as crypto from 'crypto';
import jwt from 'jsonwebtoken';

// Fix for __dirname in ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
import PizZip from 'pizzip';
import Docxtemplater from 'docxtemplater';

// Promisify execFile for async/await usage
const execFileAsync = promisify(execFile);

/**
 * Enum para engines de convers√£o DOCX‚ÜíPDF dispon√≠veis
 */
enum ConverterEngine {
  LIBREOFFICE = 'libreoffice',
  ONLYOFFICE_HTTP = 'onlyoffice-http',
  ONLYOFFICE_BUILDER = 'onlyoffice-builder'
}

/**
 * GERADOR DE DOCUMENTOS - SISTEMA ROBUSTO DOCX‚ÜíPDF
 * Usa template DOCX real com substitui√ß√£o de vari√°veis
 * Preserva layout original do template
 * SEM FALLBACK - Falha se DOCX processing n√£o funcionar
 * SISTEMA PLUGGABLE: Suporta LibreOffice (atual) e OnlyOffice HTTP (futuro)
 */
export class DocumentGenerator {

  /**
   * Determina qual engine de convers√£o usar baseado na vari√°vel de ambiente DOC_CONVERTER
   * @returns Engine de convers√£o selecionado
   */
  private static getConverterEngine(): ConverterEngine {
    const envConverter = process.env.DOC_CONVERTER?.toLowerCase();
    
    switch (envConverter) {
      case 'onlyoffice-http':
        return ConverterEngine.ONLYOFFICE_HTTP;
      case 'onlyoffice-builder':
        return ConverterEngine.ONLYOFFICE_BUILDER;
      case 'libreoffice':
      default:
        return ConverterEngine.LIBREOFFICE;
    }
  }

  /**
   * Gera documento PDF usando template DOCX real
   * Substitui vari√°veis {{nome}}, {{cpf}}, etc. preservando layout
   * FALHA se n√£o conseguir processar DOCX (sem fallback)
   */
  static async generateDocument(
    templatePath: string,
    variables: Record<string, any>,
    outputPath: string
  ): Promise<void> {
    console.log('üöÄ DocumentGenerator: Iniciando gera√ß√£o com template DOCX...');
    console.log(`Template: ${templatePath}`);
    console.log(`Variables:`, JSON.stringify(variables, null, 2));
    console.log(`Output: ${outputPath}`);

    // ETAPA 1: Validar vari√°veis obrigat√≥rias
    this.validateRequiredVariables(variables);

    // ETAPA 2: Processar template DOCX com substitui√ß√£o de vari√°veis
    await this.processDocxTemplate(templatePath, variables, outputPath);
    console.log('‚úÖ DocumentGenerator: PDF gerado com sucesso usando template DOCX!');
  }

  /**
   * Valida que todas as vari√°veis obrigat√≥rias est√£o presentes e n√£o-vazias
   */
  private static validateRequiredVariables(variables: Record<string, any>): void {
    const requiredKeys = ["nome", "cpf", "data_conclusao", "data_assinatura"];
    
    console.log('üîç Validando vari√°veis obrigat√≥rias...');
    
    const missingKeys: string[] = [];
    const emptyKeys: string[] = [];

    requiredKeys.forEach(key => {
      if (!(key in variables)) {
        missingKeys.push(key);
      } else if (!variables[key] || String(variables[key]).trim() === '') {
        emptyKeys.push(key);
      }
    });

    if (missingKeys.length > 0 || emptyKeys.length > 0) {
      let errorMessage = 'Valida√ß√£o de vari√°veis falhou:';
      
      if (missingKeys.length > 0) {
        errorMessage += `\n‚Ä¢ Vari√°veis ausentes: ${missingKeys.join(', ')}`;
      }
      
      if (emptyKeys.length > 0) {
        errorMessage += `\n‚Ä¢ Vari√°veis vazias: ${emptyKeys.join(', ')}`;
      }

      console.error('‚ùå', errorMessage);
      throw new Error(errorMessage);
    }

    console.log('‚úÖ Todas as vari√°veis obrigat√≥rias est√£o presentes e v√°lidas');
  }

  /**
   * Processa template DOCX com substitui√ß√£o de vari√°veis e converte para PDF
   */
  private static async processDocxTemplate(
    templatePath: string,
    variables: Record<string, any>,
    outputPath: string
  ): Promise<void> {
    console.log('üìÑ Processando template DOCX...');

    // Verificar se template existe
    if (!fs.existsSync(templatePath)) {
      throw new Error(`Template n√£o encontrado: ${templatePath}`);
    }

    // Carregar template DOCX
    const templateBuffer = fs.readFileSync(templatePath);
    console.log(`üìÅ Template carregado: ${templateBuffer.length} bytes`);

    // Criar PizZip do template
    const zip = new PizZip(templateBuffer);

    // Configurar Docxtemplater com configura√ß√£o tolerante
    const doc = new Docxtemplater(zip, {
      paragraphLoop: true,
      linebreaks: true,
      delimiters: { start: '{{', end: '}}' },
      nullGetter: () => ''
    });

    // Substituir vari√°veis no template
    console.log('üîÑ Substituindo vari√°veis no template...');
    doc.render(variables);

    // Gerar buffer do DOCX processado
    const processedDocxBuffer = doc.getZip().generate({ 
      type: 'nodebuffer',
      compression: 'DEFLATE'
    });

    // Criar diret√≥rio tempor√°rio
    const tempDir = path.join(__dirname, '..', 'temp');
    if (!fs.existsSync(tempDir)) {
      fs.mkdirSync(tempDir, { recursive: true });
      console.log(`üìÅ Diret√≥rio tempor√°rio criado: ${tempDir}`);
    }

    // Criar arquivos tempor√°rios
    const timestamp = Date.now();
    const tempDocxPath = path.join(tempDir, `temp_${timestamp}.docx`);
    const tempPdfPath = path.join(tempDir, `temp_${timestamp}.pdf`);

    try {
      // Salvar DOCX processado no disco
      fs.writeFileSync(tempDocxPath, processedDocxBuffer);
      console.log(`üíæ DOCX tempor√°rio salvo: ${tempDocxPath}`);

      // Converter DOCX para PDF usando LibreOffice via file-based conversion
      await this.convertDocxToPdf(tempDocxPath, tempDir);

      // Verificar se PDF foi gerado
      if (!fs.existsSync(tempPdfPath)) {
        const engine = this.getConverterEngine();
        const engineName = engine === ConverterEngine.ONLYOFFICE_HTTP ? 'OnlyOffice HTTP' : 
                          engine === ConverterEngine.ONLYOFFICE_BUILDER ? 'OnlyOffice Builder' : 'LibreOffice';
        throw new Error(`PDF n√£o foi gerado pelo ${engineName}: ${tempPdfPath}`);
      }

      // Mover PDF para destino final
      fs.copyFileSync(tempPdfPath, outputPath);
      console.log(`‚úÖ PDF gerado e salvo em: ${outputPath}`);

    } finally {
      // Limpar arquivos tempor√°rios
      this.cleanupTempFiles([tempDocxPath, tempPdfPath]);
    }
  }

  /**
   * Converte DOCX para PDF usando o engine selecionado via DOC_CONVERTER
   * Sistema pluggable que suporta LibreOffice (padr√£o) e OnlyOffice HTTP (futuro)
   */
  private static async convertDocxToPdf(docxPath: string, outputDir: string): Promise<void> {
    const engine = this.getConverterEngine();
    console.log(`üîÑ Convertendo DOCX para PDF usando engine: ${engine}`);

    switch (engine) {
      case ConverterEngine.LIBREOFFICE:
        await this.convertWithLibreOffice(docxPath, outputDir);
        break;
      
      case ConverterEngine.ONLYOFFICE_HTTP:
        await this.convertWithOnlyOfficeHttp(docxPath, outputDir);
        break;
      
      case ConverterEngine.ONLYOFFICE_BUILDER:
        await this.convertWithOnlyOfficeBuilder(docxPath, outputDir);
        break;
        
      default:
        throw new Error(`Engine de convers√£o n√£o suportado: ${engine}`);
    }
  }

  /**
   * Converte DOCX para PDF usando LibreOffice via linha de comando
   * File-based conversion (mais est√°vel que buffer-based)
   * ENGINE PADR√ÉO: Funciona local via child_process
   */
  private static async convertWithLibreOffice(docxPath: string, outputDir: string): Promise<void> {
    console.log('üìã Usando LibreOffice para convers√£o DOCX‚ÜíPDF...');

    const sofficeCommand = 'soffice';
    const args = [
      '--headless',
      '--convert-to',
      'pdf',
      '--outdir',
      outputDir,
      docxPath
    ];

    console.log(`üìù Comando LibreOffice: ${sofficeCommand} ${args.join(' ')}`);

    try {
      const { stdout, stderr } = await execFileAsync(sofficeCommand, args, {
        timeout: 30000 // 30 segundos timeout
      });

      if (stdout) {
        console.log('üì§ LibreOffice stdout:', stdout.trim());
      }

      if (stderr) {
        console.log('üì§ LibreOffice stderr:', stderr.trim());
      }

      console.log('‚úÖ LibreOffice convers√£o conclu√≠da');

    } catch (error: any) {
      console.error('‚ùå Erro na convers√£o LibreOffice:', {
        code: error.code,
        signal: error.signal,
        stdout: error.stdout,
        stderr: error.stderr,
        message: error.message
      });

      // Mensagens de erro mais espec√≠ficas baseadas no tipo de erro
      let errorMessage = 'Falha na convers√£o DOCX‚ÜíPDF: ';
      
      if (error.code === 'ENOENT') {
        errorMessage += 'LibreOffice n√£o encontrado. Instale o LibreOffice no sistema.';
      } else if (error.signal === 'SIGTERM') {
        errorMessage += 'Timeout na convers√£o (>30s). Documento muito complexo ou sistema lento.';
      } else if (error.stderr) {
        errorMessage += `LibreOffice error: ${error.stderr}`;
      } else {
        errorMessage += error.message;
      }

      throw new Error(errorMessage);
    }
  }

  /**
   * Converte DOCX para PDF usando OnlyOffice Document Server via API HTTP
   * 
   * FUNCIONALIDADES IMPLEMENTADAS:
   * - Upload DOCX para OnlyOffice Server
   * - Convers√£o s√≠ncrona e ass√≠ncrona com polling
   * - Autentica√ß√£o JWT opcional
   * - Download autom√°tico do PDF resultante
   * - Error handling robusto para timeouts e falhas de rede
   * - Retry logic para convers√µes temporariamente falhas
   * 
   * VARI√ÅVEIS DE AMBIENTE:
   * - ONLYOFFICE_SERVER_URL: URL base do OnlyOffice Server (obrigat√≥rio)
   * - ONLYOFFICE_JWT_SECRET: Chave secreta para JWT auth (opcional)
   * - ONLYOFFICE_TIMEOUT_MS: Timeout em ms (padr√£o: 60000)
   * - ONLYOFFICE_ASYNC: true=async com polling, false=sync (padr√£o: false)
   * - ONLYOFFICE_MAX_RETRIES: M√°ximo de tentativas (padr√£o: 3)
   */
  private static async convertWithOnlyOfficeHttp(docxPath: string, outputDir: string): Promise<void> {
    console.log('üåê Usando OnlyOffice Document Server para convers√£o DOCX‚ÜíPDF...');
    
    // Validar configura√ß√£o obrigat√≥ria
    const serverUrl = process.env.ONLYOFFICE_SERVER_URL;
    if (!serverUrl) {
      throw new Error('ONLYOFFICE_SERVER_URL n√£o configurado. Configure a URL do OnlyOffice Document Server.');
    }

    // Configura√ß√µes com valores padr√£o
    const jwtSecret = process.env.ONLYOFFICE_JWT_SECRET;
    const timeoutMs = parseInt(process.env.ONLYOFFICE_TIMEOUT_MS || '60000');
    const isAsync = process.env.ONLYOFFICE_ASYNC?.toLowerCase() === 'true';
    const maxRetries = parseInt(process.env.ONLYOFFICE_MAX_RETRIES || '3');

    console.log(`üìã Configura√ß√£o OnlyOffice:`, {
      serverUrl: serverUrl.replace(/\/+$/, ''), // Remove trailing slashes
      hasJWT: !!jwtSecret,
      timeoutMs,
      isAsync,
      maxRetries
    });

    // Gerar nome √∫nico para o arquivo PDF de sa√≠da (deve coincidir com processDocxTemplate)
    const timestamp = Date.now();
    const outputFileName = `temp_${timestamp}.pdf`;
    const outputPath = path.join(outputDir, outputFileName);

    let retryCount = 0;
    
    while (retryCount <= maxRetries) {
      try {
        // Etapa 1: Fazer upload do DOCX e obter URL p√∫blica
        const docxUrl = await this.uploadDocxToTempServer(docxPath);
        
        // Etapa 2: Solicitar convers√£o ao OnlyOffice
        const conversionResult = await this.requestOnlyOfficeConversion(
          docxUrl, 
          serverUrl, 
          jwtSecret, 
          timeoutMs, 
          isAsync
        );
        
        // Etapa 3: Baixar PDF resultante
        await this.downloadConvertedPdf(conversionResult.fileUrl, outputPath, timeoutMs);
        
        console.log(`‚úÖ OnlyOffice convers√£o conclu√≠da: ${outputPath}`);
        return;
        
      } catch (error: any) {
        retryCount++;
        console.error(`‚ùå Tentativa ${retryCount}/${maxRetries + 1} falhou:`, error.message);
        
        if (retryCount > maxRetries) {
          throw new Error(`OnlyOffice convers√£o falhou ap√≥s ${maxRetries + 1} tentativas: ${error.message}`);
        }
        
        // Aguardar antes da pr√≥xima tentativa (exponential backoff)
        const backoffDelay = Math.min(1000 * Math.pow(2, retryCount - 1), 10000);
        console.log(`‚è≥ Aguardando ${backoffDelay}ms antes da pr√≥xima tentativa...`);
        await new Promise(resolve => setTimeout(resolve, backoffDelay));
      }
    }
  }

  /**
   * Faz upload do DOCX para um servidor tempor√°rio e retorna URL p√∫blica
   * NOTA: Em produ√ß√£o, voc√™ pode usar seu pr√≥prio servidor web ou servi√ßo de storage
   * Para simplificar, esta implementa√ß√£o assume que voc√™ tem um endpoint HTTP acess√≠vel
   */
  private static async uploadDocxToTempServer(docxPath: string): Promise<string> {
    console.log('üì§ Fazendo upload do DOCX para servidor tempor√°rio...');
    
    // Ler o arquivo DOCX
    const docxBuffer = fs.readFileSync(docxPath);
    const fileName = `temp_${Date.now()}_${path.basename(docxPath)}`;
    
    // IMPLEMENTA√á√ÉO SIMPLIFICADA: Usar servidor HTTP local
    // Em produ√ß√£o, substitua por seu servi√ßo de upload preferido (AWS S3, etc.)
    const localServerUrl = process.env.LOCAL_SERVER_URL || 'http://localhost:3000';
    const uploadUrl = `${localServerUrl}/uploads/temp/${fileName}`;
    
    // Salvar arquivo temporariamente em pasta acess√≠vel via HTTP
    const tempUploadDir = path.join(__dirname, '..', 'uploads', 'temp');
    if (!fs.existsSync(tempUploadDir)) {
      fs.mkdirSync(tempUploadDir, { recursive: true });
    }
    
    const tempFilePath = path.join(tempUploadDir, fileName);
    fs.writeFileSync(tempFilePath, docxBuffer);
    
    console.log(`üìÅ DOCX dispon√≠vel em: ${uploadUrl}`);
    return uploadUrl;
  }

  /**
   * Solicita convers√£o ao OnlyOffice Document Server
   */
  private static async requestOnlyOfficeConversion(
    docxUrl: string,
    serverUrl: string,
    jwtSecret: string | undefined,
    timeoutMs: number,
    isAsync: boolean
  ): Promise<{ fileUrl: string }> {
    console.log('üîÑ Solicitando convers√£o ao OnlyOffice Document Server...');
    
    // Endpoint de convers√£o (vers√µes novas usam /converter, antigas /ConvertService.ashx)
    const conversionEndpoint = `${serverUrl.replace(/\/+$/, '')}/ConvertService.ashx`;
    
    // Gerar chave √∫nica para a convers√£o
    const conversionKey = this.generateConversionKey();
    
    // Payload da requisi√ß√£o
    const payload = {
      async: isAsync,
      filetype: 'docx',
      key: conversionKey,
      outputtype: 'pdf',
      title: `converted_${Date.now()}.pdf`,
      url: docxUrl
    };

    console.log('üìù Payload da convers√£o:', JSON.stringify(payload, null, 2));

    // Adicionar JWT se configurado
    let requestBody: any = payload;
    const headers: Record<string, string> = {
      'Content-Type': 'application/json'
    };

    if (jwtSecret) {
      console.log('üîê Adicionando autentica√ß√£o JWT...');
      
      // Implementa√ß√£o JWT segura usando jsonwebtoken com HS256
      const jwtToken = this.createSecureJWT(payload, jwtSecret);
      requestBody = { ...payload, token: jwtToken };
    }

    try {
      // Fazer requisi√ß√£o HTTP
      const response = await fetch(conversionEndpoint, {
        method: 'POST',
        headers,
        body: JSON.stringify(requestBody),
        signal: AbortSignal.timeout(timeoutMs)
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const result = await response.json();
      console.log('üì• Resposta OnlyOffice:', JSON.stringify(result, null, 2));

      // Verificar se houve erro
      if (result.error !== undefined) {
        throw new Error(`OnlyOffice API error ${result.error}: ${this.getOnlyOfficeErrorMessage(result.error)}`);
      }

      // Se convers√£o ass√≠ncrona, fazer polling
      if (isAsync && result.endConvert !== true) {
        console.log('‚è≥ Convers√£o ass√≠ncrona iniciada, fazendo polling...');
        return await this.pollOnlyOfficeConversion(conversionEndpoint, conversionKey, jwtSecret, timeoutMs);
      }

      // Convers√£o s√≠ncrona ou ass√≠ncrona conclu√≠da
      if (!result.fileUrl) {
        throw new Error('OnlyOffice n√£o retornou URL do arquivo convertido');
      }

      console.log('‚úÖ Convers√£o OnlyOffice conclu√≠da');
      return { fileUrl: result.fileUrl };

    } catch (error: any) {
      if (error.name === 'TimeoutError') {
        throw new Error(`Timeout na convers√£o OnlyOffice (>${timeoutMs}ms)`);
      }
      throw error;
    }
  }

  /**
   * Faz polling para convers√£o ass√≠ncrona
   */
  private static async pollOnlyOfficeConversion(
    conversionEndpoint: string,
    conversionKey: string,
    jwtSecret: string | undefined,
    timeoutMs: number
  ): Promise<{ fileUrl: string }> {
    const startTime = Date.now();
    const pollInterval = 2000; // 2 segundos entre polls
    
    while (Date.now() - startTime < timeoutMs) {
      console.log('üîÑ Verificando status da convers√£o...');
      
      const payload = { key: conversionKey };
      let requestBody: any = payload;
      
      if (jwtSecret) {
        const jwtToken = this.createSecureJWT(payload, jwtSecret);
        requestBody = { ...payload, token: jwtToken };
      }

      try {
        const response = await fetch(conversionEndpoint, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(requestBody),
          signal: AbortSignal.timeout(10000) // 10s timeout por poll
        });

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const result = await response.json();
        
        if (result.error !== undefined) {
          throw new Error(`OnlyOffice polling error ${result.error}: ${this.getOnlyOfficeErrorMessage(result.error)}`);
        }

        if (result.endConvert === true && result.fileUrl) {
          console.log('‚úÖ Convers√£o ass√≠ncrona conclu√≠da');
          return { fileUrl: result.fileUrl };
        }

        // Aguardar pr√≥ximo poll
        await new Promise(resolve => setTimeout(resolve, pollInterval));
        
      } catch (error: any) {
        console.warn('‚ö†Ô∏è Erro no polling, tentando novamente...', error.message);
        await new Promise(resolve => setTimeout(resolve, pollInterval));
      }
    }
    
    throw new Error(`Timeout no polling da convers√£o OnlyOffice (>${timeoutMs}ms)`);
  }

  /**
   * Baixa o PDF convertido do OnlyOffice
   */
  private static async downloadConvertedPdf(fileUrl: string, outputPath: string, timeoutMs: number): Promise<void> {
    console.log(`üì• Baixando PDF convertido: ${fileUrl}`);
    
    try {
      const response = await fetch(fileUrl, {
        signal: AbortSignal.timeout(timeoutMs)
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const pdfBuffer = await response.arrayBuffer();
      fs.writeFileSync(outputPath, Buffer.from(pdfBuffer));
      
      console.log(`üíæ PDF salvo: ${outputPath} (${pdfBuffer.byteLength} bytes)`);
      
    } catch (error: any) {
      if (error.name === 'TimeoutError') {
        throw new Error(`Timeout no download do PDF (>${timeoutMs}ms)`);
      }
      throw error;
    }
  }

  /**
   * Gera chave √∫nica para convers√£o OnlyOffice (m√≠nimo 12 caracteres)
   */
  private static generateConversionKey(): string {
    return `conv_${Date.now()}_${crypto.randomBytes(8).toString('hex')}`;
  }

  /**
   * Cria JWT seguro para autentica√ß√£o OnlyOffice usando jsonwebtoken
   * Implementa HS256 corretamente conforme especifica√ß√£o OnlyOffice
   */
  private static createSecureJWT(payload: any, secret: string): string {
    // OnlyOffice espera payload no campo 'payload' quando usando JWT
    const tokenPayload = {
      payload: payload,
      iss: 'document-generator',
      aud: 'onlyoffice',
      iat: Math.floor(Date.now() / 1000),
      exp: Math.floor(Date.now() / 1000) + (5 * 60) // 5 minutos de validade
    };

    return jwt.sign(tokenPayload, secret, {
      algorithm: 'HS256',
      header: {
        alg: 'HS256',
        typ: 'JWT'
      }
    });
  }

  /**
   * Converte c√≥digos de erro OnlyOffice em mensagens leg√≠veis
   */
  private static getOnlyOfficeErrorMessage(errorCode: number): string {
    const errorMessages: Record<number, string> = {
      '-1': 'Erro desconhecido',
      '-2': 'Timeout na convers√£o',
      '-3': 'Erro na convers√£o do documento',
      '-4': 'Erro no download do documento de origem',
      '-5': 'Formato de arquivo n√£o suportado',
      '-6': 'Documento corrompido ou inv√°lido',
      '-7': 'Documento protegido por senha',
      '-8': 'Par√¢metros inv√°lidos'
    };
    
    return errorMessages[errorCode] || `Erro OnlyOffice ${errorCode}`;
  }

  /**
   * Converte DOCX para PDF usando OnlyOffice Document Builder (biblioteca JavaScript)
   * 
   * VANTAGENS DO DOCUMENT BUILDER:
   * - ‚úÖ Biblioteca JavaScript nativa (sem servidor externo)
   * - ‚úÖ Performance superior ao LibreOffice (sem fork de processo)
   * - ‚úÖ API program√°tica completa para manipula√ß√£o de documentos
   * - ‚úÖ Melhor compatibilidade com DOCX (engine OnlyOffice nativo)
   * - ‚úÖ Zero configura√ß√£o (NPM install apenas)
   * - ‚úÖ Execu√ß√£o local (sem depend√™ncias de rede)
   * 
   * INSTALA√á√ÉO: npm install @onlyoffice/documentbuilder
   * USO: export DOC_CONVERTER=onlyoffice-builder
   */
  private static async convertWithOnlyOfficeBuilder(docxPath: string, outputDir: string): Promise<void> {
    console.log('üìö Usando OnlyOffice Document Builder para convers√£o DOCX‚ÜíPDF...');
    
    try {
      // Importar OnlyOffice Document Builder dinamicamente
      const docBuilder = await import('@onlyoffice/documentbuilder');
      
      // Gerar nome do arquivo PDF de sa√≠da (deve coincidir com processDocxTemplate)
      const timestamp = Date.now();
      const outputFileName = `temp_${timestamp}.pdf`;
      const outputPath = path.join(outputDir, outputFileName);
      
      console.log(`üìÑ Convertendo: ${path.basename(docxPath)} ‚Üí ${outputFileName}`);
      
      // Inicializar Document Builder
      console.log('üîß Inicializando OnlyOffice Document Builder...');
      
      // Abrir documento DOCX existente
      console.log(`üìÇ Abrindo documento: ${docxPath}`);
      const oDocument = docBuilder.GetDocument(docxPath);
      
      if (!oDocument) {
        throw new Error('Falha ao abrir documento DOCX com OnlyOffice Document Builder');
      }
      
      console.log('‚úÖ Documento DOCX carregado com sucesso');
      
      // Converter para PDF e salvar
      console.log(`üíæ Salvando como PDF: ${outputPath}`);
      const saveResult = oDocument.SaveAs(outputPath, 'pdf');
      
      if (!saveResult) {
        throw new Error('Falha na convers√£o DOCX‚ÜíPDF com OnlyOffice Document Builder');
      }
      
      // Verificar se arquivo foi criado
      if (!fs.existsSync(outputPath)) {
        throw new Error(`PDF n√£o foi gerado: ${outputPath}`);
      }
      
      const pdfStats = fs.statSync(outputPath);
      console.log(`‚úÖ OnlyOffice Document Builder convers√£o conclu√≠da: ${pdfStats.size} bytes`);
      
    } catch (error: any) {
      console.error('‚ùå Erro na convers√£o OnlyOffice Document Builder:', error);
      
      // Mensagens de erro espec√≠ficas
      let errorMessage = 'Falha na convers√£o DOCX‚ÜíPDF com OnlyOffice Document Builder: ';
      
      if (error.code === 'MODULE_NOT_FOUND' && error.message.includes('@onlyoffice/documentbuilder')) {
        errorMessage += 'M√≥dulo @onlyoffice/documentbuilder n√£o encontrado. Execute: npm install @onlyoffice/documentbuilder';
      } else if (error.message.includes('GetDocument')) {
        errorMessage += 'Falha ao abrir documento DOCX. Verifique se o arquivo est√° v√°lido.';
      } else if (error.message.includes('SaveAs')) {
        errorMessage += 'Falha na convers√£o para PDF. Documento pode estar corrompido.';
      } else {
        errorMessage += error.message;
      }
      
      throw new Error(errorMessage);
    }
  }

  /**
   * Remove arquivos tempor√°rios com log de limpeza
   */
  private static cleanupTempFiles(filePaths: string[]): void {
    console.log('üßπ Limpando arquivos tempor√°rios...');
    
    let cleanedCount = 0;
    
    filePaths.forEach(filePath => {
      try {
        if (fs.existsSync(filePath)) {
          fs.unlinkSync(filePath);
          console.log(`üóëÔ∏è Removido: ${path.basename(filePath)}`);
          cleanedCount++;
        }
      } catch (cleanupError) {
        console.warn(`‚ö†Ô∏è Falha ao remover ${path.basename(filePath)}:`, cleanupError);
      }
    });

    console.log(`‚úÖ Limpeza conclu√≠da: ${cleanedCount} arquivos removidos`);
  }
}